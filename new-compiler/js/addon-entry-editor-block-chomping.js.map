{"version":3,"file":"js/addon-entry-editor-block-chomping.js","sources":["webpack://GUI/./src/addons/addons/editor-block-chomping/_runtime_entry.js","webpack://GUI/./src/addons/addons/editor-block-chomping/userscript.js"],"sourcesContent":["import _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","export default async function ({ addon }) {\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n\n  // Rerender the dragged block when updating the insertion marker\n  const ogConnectMarker = ScratchBlocks.InsertionMarkerManager.prototype.connectMarker_;\n  ScratchBlocks.InsertionMarkerManager.prototype.connectMarker_ = function () {\n    ogConnectMarker.call(this);\n    if (!addon.self.disabled && this.firstMarker_) {\n      const block = this?.workspace_?.currentGesture_?.blockDragger_?.draggingBlock_;\n      block.noMoveConnection = true;\n      if (block) block.render(false);\n    }\n  };\n  const ogDisconnectMarker = ScratchBlocks.InsertionMarkerManager.prototype.disconnectMarker_;\n  ScratchBlocks.InsertionMarkerManager.prototype.disconnectMarker_ = function () {\n    ogDisconnectMarker.call(this);\n    if (!addon.self.disabled && this.firstMarker_) {\n      const block = this?.workspace_?.currentGesture_?.blockDragger_?.draggingBlock_;\n      block.noMoveConnection = true;\n      if (block) block.render(false);\n    }\n  };\n\n  const ogDraw = ScratchBlocks.BlockSvg.prototype.renderDraw_;\n  const ogMoveConnections = ScratchBlocks.BlockSvg.prototype.renderMoveConnections_;\n  ScratchBlocks.BlockSvg.prototype.renderDraw_ = function (iconWidth, inputRows) {\n    if (addon.self.disabled) return ogDraw.call(this, iconWidth, inputRows);\n\n    // If the block contains a statement (C) input and has an insertion marker,\n    // use that to calculate the height of the statement inputs\n    let computeBlock = this;\n    if (this?.workspace?.currentGesture_?.blockDragger_?.draggedConnectionManager_) {\n      const dragger = this.workspace.currentGesture_.blockDragger_;\n      const manager = dragger.draggedConnectionManager_;\n      if (\n        manager.markerConnection_ &&\n        manager.firstMarker_ &&\n        dragger.draggingBlock_ == this &&\n        dragger.draggingBlock_.type == manager.firstMarker_.type\n      ) {\n        if (inputRows.some((row) => row.some((input) => input.type === ScratchBlocks.NEXT_STATEMENT))) {\n          computeBlock = manager.firstMarker_;\n        }\n      }\n    }\n\n    // Change the height of substacks\n    // (If we set inputRows to computeBlock.renderCompute_,\n    // the references to the inputs would be wrong\n    // so they just won't update properly)\n    if (computeBlock !== this) {\n      const _inputRows = computeBlock.renderCompute_(iconWidth);\n      for (let i = 0; i < inputRows.length; i++) {\n        const row = inputRows[i];\n        let update = false;\n        for (const input of row) {\n          if (input.type === ScratchBlocks.NEXT_STATEMENT) update = true;\n        }\n        if (update) row.height = Math.max(row.height, _inputRows[i].height);\n      }\n    }\n\n    ogDraw.call(this, iconWidth, inputRows);\n\n    // Moving the connections of a block while it's being dragged breaks it,\n    // so don't\n    if (computeBlock === this && !this.noMoveConnection) ogMoveConnections.call(this);\n    this.noMoveConnection = false;\n  };\n  ScratchBlocks.BlockSvg.prototype.renderMoveConnections_ = function () {\n    if (addon.self.disabled) return ogMoveConnections.call(this);\n    // Do nothing (this function is instead called by renderDraw_)\n  };\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}